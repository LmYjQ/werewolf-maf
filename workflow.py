# Copyright (c) Microsoft. All rights reserved.
"""Workflow definition for Werewolf (谁是卧底) game.

This module defines the workflow for the game.
"""

from dataclasses import dataclass
from agent_framework import (
    WorkflowBuilder,
    WorkflowContext,
    Executor,
    AgentExecutorResponse,
    AgentExecutorRequest,
    ChatMessage,
    Role,
    handler,
    response_handler,
    AgentExecutor,
)

from word_agent import setup_word_agent, generate_word_pair
from game_agent import (
    create_game,
    GameState,
    setup_ai_speech_agent,
    setup_ai_voting_agent,
    generate_ai_speech,
    generate_ai_vote,
    next_player,
    process_vote,
)


@dataclass
class GameStartRequest:
    """Request to start a new game."""
    category: str
    num_ai_players: int = 3


@dataclass
class SpeechRequest:
    """Request for AI player speech."""
    game_state: dict
    player_name: str


@dataclass
class VoteRequest:
    """Request for AI player vote."""
    game_state: dict
    player_name: str


class WordExecutor(Executor):
    """Executor that generates word pairs for the game."""

    def __init__(self, id: str):
        super().__init__(id=id)
        self._word_agent = setup_word_agent()

    @handler
    async def generate_words(self, response: AgentExecutorResponse, ctx: WorkflowContext) -> None:
        """Generate word pair for the game."""
        # Get the request data
        request = ctx.get_initial_request_data()
        category = request.category if hasattr(request, 'category') else "随机"

        # Generate word pair
        word_pair = await generate_word_pair(self._word_agent, category)

        # Yield the result
        await ctx.yield_output({
            "civilian_word": word_pair.civilian_word,
            "spy_word": word_pair.spy_word,
            "category": word_pair.category
        })


class AISpeechExecutor(Executor):
    """Executor that generates speech for AI players."""

    def __init__(self, id: str):
        super().__init__(id=id)
        self._speech_agent = setup_ai_speech_agent()

    @handler
    async def generate_speech(self, response: AgentExecutorResponse, ctx: WorkflowContext) -> None:
        """Generate speech for an AI player."""
        request = ctx.get_initial_request_data()
        game_state_dict = request.get("game_state", {})
        player_name = request.get("player_name", "")

        # Reconstruct game state (simplified)
        # In practice, this would use the actual GameState object from the session

        await ctx.yield_output({
            "player_name": player_name,
            "speech": "这是一个测试发言"  # Placeholder - actual speech generated by streamlit
        })


class AIVoteExecutor(Executor):
    """Executor that generates votes for AI players."""

    def __init__(self, id: str):
        super().__init__(id=id)
        self._vote_agent = setup_ai_voting_agent()

    @handler
    async def generate_vote(self, response: AgentExecutorResponse, ctx: WorkflowContext) -> None:
        """Generate vote for an AI player."""
        request = ctx.get_initial_request_data()
        game_state_dict = request.get("game_state", {})
        player_name = request.get("player_name", "")

        await ctx.yield_output({
            "player_name": player_name,
            "vote": "小红"  # Placeholder - actual vote generated by streamlit
        })


# Note: For this game, most logic is handled directly in streamlit_app.py
# The workflow provides the agent integration for word generation and AI behaviors
# but the game state management is done in the UI for better user experience.

# Workflow entry point function
async def start_game_workflow(category: str, num_ai_players: int = 3):
    """Start a new game workflow."""
    word_agent = setup_word_agent()
    word_pair = await generate_word_pair(word_agent, category)

    game_state = create_game(
        category=category,
        civilian_word=word_pair.civilian_word,
        spy_word=word_pair.spy_word,
        num_ai_players=num_ai_players
    )

    return game_state
